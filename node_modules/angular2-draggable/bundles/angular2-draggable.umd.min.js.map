{"version":3,"file":"angular2-draggable.umd.min.js","sources":["~/angular2-draggable/src/directive/angular-draggable.directive.ts","~/angular2-draggable/src/angular-draggable.module.ts"],"sourcesContent":["import { Directive, ElementRef, Renderer2, Input, Output, OnInit, HostListener, EventEmitter, OnChanges, SimpleChanges } from '@angular/core';\n\nexport interface IPosition {\n  x: number;\n  y: number;\n}\nclass Position implements IPosition {\n/**\n * @param {?} x\n * @param {?} y\n */\nconstructor(public x: number,\npublic y: number) { }\n/**\n * @param {?} e\n * @return {?}\n */\nstatic fromEvent(e: MouseEvent | TouchEvent) {\n    if (e instanceof MouseEvent) {\n      return new Position(e.clientX, e.clientY);\n    } else {\n      return new Position(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n    }\n  }\n/**\n * @param {?} obj\n * @return {?}\n */\nstatic isIPosition(obj): obj is IPosition {\n    return !!obj && ('x' in obj) && ('y' in obj);\n  }\n/**\n * @param {?} p\n * @return {?}\n */\nadd(p: IPosition) {\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n/**\n * @param {?} p\n * @return {?}\n */\nsubtract(p: IPosition) {\n    this.x -= p.x;\n    this.y -= p.y;\n    return this;\n  }\n/**\n * @return {?}\n */\nreset() {\n    this.x = 0;\n    this.y = 0;\n    return this;\n  }\n/**\n * @param {?} p\n * @return {?}\n */\nset(p: IPosition) {\n    this.x = p.x;\n    this.y = p.y;\n    return this;\n  }\n}\n\nfunction Position_tsickle_Closure_declarations() {\n/** @type {?} */\nPosition.prototype.x;\n/** @type {?} */\nPosition.prototype.y;\n}\n\nexport class AngularDraggableDirective implements OnInit, OnChanges {\nprivate allowDrag = true;\nprivate moving = false;\nprivate orignal: Position = null;\nprivate oldTrans = new Position(0, 0);\nprivate tempTrans = new Position(0, 0);\nprivate oldZIndex = '';\nprivate oldPosition = '';\nprivate _zIndex = '';\nprivate needTransform = false;\n\n   started = new EventEmitter<any>();\n   stopped = new EventEmitter<any>();\n   edge = new EventEmitter<any>();\n/**\n * Make the handle HTMLElement draggable\n */\nhandle: HTMLElement;\n/**\n * Set the bounds HTMLElement\n */\nbounds: HTMLElement;\n/**\n * List of allowed out of bounds edges *\n */\noutOfBounds = {\n    top: false,\n    right: false,\n    bottom: false,\n    left: false\n  };\n/**\n * Round the position to nearest grid\n */\ngridSize = 1;\n/**\n * Set z-index when dragging\n */\nzIndexMoving: string;\n/**\n * Set z-index when not dragging\n * @param {?} setting\n * @return {?}\n */\nset zIndex(setting: string) {\n    this.renderer.setStyle(this.el.nativeElement, 'z-index', setting);\n    this._zIndex = setting;\n  }\n/**\n * Whether to limit the element stay in the bounds\n */\ninBounds = false;\n/**\n * Whether the element should use it's previous drag position on a new drag event.\n */\ntrackPosition = true;\n/**\n * Input css scale transform of element so translations are correct\n */\nscale = 1;\n/**\n * Whether to prevent default event\n */\npreventDefaultEvent = false;\n/**\n * Set initial position by offsets\n */\nposition: IPosition = { x: 0, y: 0 };\n/**\n * Emit position offsets when moving\n */\nmovingOffset = new EventEmitter<IPosition>();\n/**\n * Emit position offsets when put back\n */\nendOffset = new EventEmitter<IPosition>();\n/**\n * @param {?} setting\n * @return {?}\n */\nset ngDraggable(setting: any) {\n    if (setting !== undefined && setting !== null && setting !== '') {\n      this.allowDrag = !!setting;\n\n      let /** @type {?} */ element = this.handle ? this.handle : this.el.nativeElement;\n\n      if (this.allowDrag) {\n        this.renderer.addClass(element, 'ng-draggable');\n      } else {\n        this.renderer.removeClass(element, 'ng-draggable');\n      }\n    }\n  }\n/**\n * @param {?} el\n * @param {?} renderer\n */\nconstructor(private el: ElementRef,\nprivate renderer: Renderer2) { }\n/**\n * @return {?}\n */\nngOnInit() {\n    if (this.allowDrag) {\n      let /** @type {?} */ element = this.handle ? this.handle : this.el.nativeElement;\n      this.renderer.addClass(element, 'ng-draggable');\n    }\n\n    this.resetPosition();\n  }\n/**\n * @param {?} changes\n * @return {?}\n */\nngOnChanges(changes: SimpleChanges) {\n    if (changes['position'] && !changes['position'].isFirstChange()) {\n      let /** @type {?} */ p = changes['position'].currentValue;\n\n      if (!this.moving) {\n        if (Position.isIPosition(p)) {\n          this.oldTrans.set(p);\n        } else {\n          this.oldTrans.reset();\n        }\n\n        this.transform();\n      } else {\n        this.needTransform = true;\n      }\n    }\n  }\n/**\n * @return {?}\n */\nresetPosition() {\n    if (Position.isIPosition(this.position)) {\n      this.oldTrans.set(this.position);\n    } else {\n      this.oldTrans.reset();\n    }\n    this.tempTrans.reset();\n    this.transform();\n  }\n/**\n * @param {?} p\n * @return {?}\n */\nprivate moveTo(p: Position) {\n    if (this.orignal) {\n      p.subtract(this.orignal);\n      this.tempTrans.set(p);\n      this.transform();\n\n      if (this.bounds) {\n        this.edge.emit(this.boundsCheck());\n      }\n\n      this.movingOffset.emit({\n        x: this.tempTrans.x + this.oldTrans.x,\n        y: this.tempTrans.y + this.oldTrans.y\n      });\n    }\n  }\n/**\n * @return {?}\n */\nprivate transform() {\n\n    let /** @type {?} */ translateX = this.tempTrans.x + this.oldTrans.x;\n    let /** @type {?} */ translateY = this.tempTrans.y + this.oldTrans.y;\n\n    // Snap to grid: by grid size\n    if (this.gridSize > 1) {\n      translateX = Math.round(translateX / this.gridSize) * this.gridSize;\n      translateY = Math.round(translateY / this.gridSize) * this.gridSize;\n    }\n\n    let /** @type {?} */ value = `translate(${translateX}px, ${translateY}px)`;\n\n    if (this.scale !== 1) {\n      value += ` scale(${this.scale})`;\n    }\n\n    this.renderer.setStyle(this.el.nativeElement, 'transform', value);\n    this.renderer.setStyle(this.el.nativeElement, '-webkit-transform', value);\n    this.renderer.setStyle(this.el.nativeElement, '-ms-transform', value);\n    this.renderer.setStyle(this.el.nativeElement, '-moz-transform', value);\n    this.renderer.setStyle(this.el.nativeElement, '-o-transform', value);\n  }\n/**\n * @return {?}\n */\nprivate pickUp() {\n    // get old z-index:\n    this.oldZIndex = this.el.nativeElement.style.zIndex ? this.el.nativeElement.style.zIndex : '';\n\n    if (window) {\n      this.oldZIndex = window.getComputedStyle(this.el.nativeElement, null).getPropertyValue('z-index');\n    }\n\n    if (this.zIndexMoving) {\n      this.renderer.setStyle(this.el.nativeElement, 'z-index', this.zIndexMoving);\n    }\n\n    if (!this.moving) {\n      this.started.emit(this.el.nativeElement);\n      this.moving = true;\n    }\n  }\n/**\n * @return {?}\n */\nboundsCheck() {\n    if (this.bounds) {\n      let /** @type {?} */ boundary = this.bounds.getBoundingClientRect();\n      let /** @type {?} */ elem = this.el.nativeElement.getBoundingClientRect();\n      let /** @type {?} */ result = {\n        'top': this.outOfBounds.top ? true : boundary.top < elem.top,\n        'right': this.outOfBounds.right ? true : boundary.right > elem.right,\n        'bottom': this.outOfBounds.bottom ? true : boundary.bottom > elem.bottom,\n        'left': this.outOfBounds.left ? true : boundary.left < elem.left\n      };\n\n      if (this.inBounds) {\n        if (!result.top) {\n          this.tempTrans.y -= elem.top - boundary.top;\n        }\n\n        if (!result.bottom) {\n          this.tempTrans.y -= elem.bottom - boundary.bottom;\n        }\n\n        if (!result.right) {\n          this.tempTrans.x -= elem.right - boundary.right;\n        }\n\n        if (!result.left) {\n          this.tempTrans.x -= elem.left - boundary.left;\n        }\n\n        this.transform();\n      }\n\n      return result;\n    }\n  }\n/**\n * @return {?}\n */\nprivate putBack() {\n    if (this._zIndex) {\n      this.renderer.setStyle(this.el.nativeElement, 'z-index', this._zIndex);\n    } else if (this.zIndexMoving) {\n      if (this.oldZIndex) {\n        this.renderer.setStyle(this.el.nativeElement, 'z-index', this.oldZIndex);\n      } else {\n        this.el.nativeElement.style.removeProperty('z-index');\n      }\n    }\n\n    if (this.moving) {\n      this.stopped.emit(this.el.nativeElement);\n\n      if (this.needTransform) {\n        if (Position.isIPosition(this.position)) {\n          this.oldTrans.set(this.position);\n        } else {\n          this.oldTrans.reset();\n        }\n\n        this.transform();\n        this.needTransform = false;\n      }\n\n      if (this.bounds) {\n        this.edge.emit(this.boundsCheck());\n      }\n\n      this.moving = false;\n      this.endOffset.emit({\n        x: this.tempTrans.x + this.oldTrans.x,\n        y: this.tempTrans.y + this.oldTrans.y\n      });\n\n      if (this.trackPosition) {\n        this.oldTrans.add(this.tempTrans);\n      }\n\n      this.tempTrans.reset();\n\n      if (!this.trackPosition) {\n        this.transform();\n      }\n    }\n  }\n/**\n * @param {?} target\n * @param {?} element\n * @return {?}\n */\ncheckHandleTarget(target: EventTarget, element: Element) {\n    // Checks if the target is the element clicked, then checks each child element of element as well\n    // Ignores button clicks\n\n    // Ignore elements of type button\n    if (element.tagName === 'BUTTON') {\n      return false;\n    }\n\n    // If the target was found, return true (handle was found)\n    if (element === target) {\n      return true;\n    }\n\n    // Recursively iterate this elements children\n    for (let /** @type {?} */ child in element.children) {\n      if (element.children.hasOwnProperty(child)) {\n        if (this.checkHandleTarget(target, element.children[child])) {\n          return true;\n        }\n      }\n    }\n\n    // Handle was not found in this lineage\n    // Note: return false is ignore unless it is the parent element\n    return false;\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nonMouseDown(event: MouseEvent | TouchEvent) {\n    // 1. skip right click;\n    if (event instanceof MouseEvent && event.button === 2) {\n      return;\n    }\n    // 2. if handle is set, the element can only be moved by handle\n    let /** @type {?} */ target = event.target || event.srcElement;\n    if (this.handle !== undefined && !this.checkHandleTarget(target, this.handle)) {\n      return;\n    }\n\n    if (this.preventDefaultEvent) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n\n    this.orignal = Position.fromEvent(event);\n    this.pickUp();\n  }\n/**\n * @return {?}\n */\nonMouseLeave() {\n    this.putBack();\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nonMouseMove(event: MouseEvent | TouchEvent) {\n    if (this.moving && this.allowDrag) {\n      if (this.preventDefaultEvent) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n\n      this.moveTo(Position.fromEvent(event));\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[ngDraggable]',\n  exportAs: 'ngDraggable'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: Renderer2, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'started': [{ type: Output },],\n'stopped': [{ type: Output },],\n'edge': [{ type: Output },],\n'handle': [{ type: Input },],\n'bounds': [{ type: Input },],\n'outOfBounds': [{ type: Input },],\n'gridSize': [{ type: Input },],\n'zIndexMoving': [{ type: Input },],\n'zIndex': [{ type: Input },],\n'inBounds': [{ type: Input },],\n'trackPosition': [{ type: Input },],\n'scale': [{ type: Input },],\n'preventDefaultEvent': [{ type: Input },],\n'position': [{ type: Input },],\n'movingOffset': [{ type: Output },],\n'endOffset': [{ type: Output },],\n'ngDraggable': [{ type: Input },],\n'onMouseDown': [{ type: HostListener, args: ['mousedown', ['$event'], ] },{ type: HostListener, args: ['touchstart', ['$event'], ] },],\n'onMouseLeave': [{ type: HostListener, args: ['document:mouseup', ] },{ type: HostListener, args: ['document:mouseleave', ] },{ type: HostListener, args: ['document:touchend', ] },{ type: HostListener, args: ['document:touchcancel', ] },],\n'onMouseMove': [{ type: HostListener, args: ['document:mousemove', ['$event'], ] },{ type: HostListener, args: ['document:touchmove', ['$event'], ] },],\n};\n}\n\nfunction AngularDraggableDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nAngularDraggableDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nAngularDraggableDirective.ctorParameters;\n/** @type {?} */\nAngularDraggableDirective.propDecorators;\n/** @type {?} */\nAngularDraggableDirective.prototype.allowDrag;\n/** @type {?} */\nAngularDraggableDirective.prototype.moving;\n/** @type {?} */\nAngularDraggableDirective.prototype.orignal;\n/** @type {?} */\nAngularDraggableDirective.prototype.oldTrans;\n/** @type {?} */\nAngularDraggableDirective.prototype.tempTrans;\n/** @type {?} */\nAngularDraggableDirective.prototype.oldZIndex;\n/** @type {?} */\nAngularDraggableDirective.prototype.oldPosition;\n/** @type {?} */\nAngularDraggableDirective.prototype._zIndex;\n/** @type {?} */\nAngularDraggableDirective.prototype.needTransform;\n/** @type {?} */\nAngularDraggableDirective.prototype.started;\n/** @type {?} */\nAngularDraggableDirective.prototype.stopped;\n/** @type {?} */\nAngularDraggableDirective.prototype.edge;\n/**\n * Make the handle HTMLElement draggable\n * @type {?}\n */\nAngularDraggableDirective.prototype.handle;\n/**\n * Set the bounds HTMLElement\n * @type {?}\n */\nAngularDraggableDirective.prototype.bounds;\n/**\n * List of allowed out of bounds edges *\n * @type {?}\n */\nAngularDraggableDirective.prototype.outOfBounds;\n/**\n * Round the position to nearest grid\n * @type {?}\n */\nAngularDraggableDirective.prototype.gridSize;\n/**\n * Set z-index when dragging\n * @type {?}\n */\nAngularDraggableDirective.prototype.zIndexMoving;\n/**\n * Whether to limit the element stay in the bounds\n * @type {?}\n */\nAngularDraggableDirective.prototype.inBounds;\n/**\n * Whether the element should use it's previous drag position on a new drag event.\n * @type {?}\n */\nAngularDraggableDirective.prototype.trackPosition;\n/**\n * Input css scale transform of element so translations are correct\n * @type {?}\n */\nAngularDraggableDirective.prototype.scale;\n/**\n * Whether to prevent default event\n * @type {?}\n */\nAngularDraggableDirective.prototype.preventDefaultEvent;\n/**\n * Set initial position by offsets\n * @type {?}\n */\nAngularDraggableDirective.prototype.position;\n/**\n * Emit position offsets when moving\n * @type {?}\n */\nAngularDraggableDirective.prototype.movingOffset;\n/**\n * Emit position offsets when put back\n * @type {?}\n */\nAngularDraggableDirective.prototype.endOffset;\n/** @type {?} */\nAngularDraggableDirective.prototype.el;\n/** @type {?} */\nAngularDraggableDirective.prototype.renderer;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\nimport { AngularDraggableDirective, IPosition } from './directive/angular-draggable.directive';\nexport class AngularDraggableModule { static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [\n    AngularDraggableDirective\n  ],\n  exports: [\n    AngularDraggableDirective\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction AngularDraggableModule_tsickle_Closure_declarations() {\n/** @type {?} */\nAngularDraggableModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nAngularDraggableModule.ctorParameters;\n}\n\n\nexport { AngularDraggableDirective, IPosition };\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["Position","x","y","this","fromEvent","e","MouseEvent","clientX","clientY","changedTouches","isIPosition","obj","prototype","add","p","subtract","reset","set","AngularDraggableDirective","el","renderer","allowDrag","moving","orignal","oldTrans","tempTrans","oldZIndex","oldPosition","_zIndex","needTransform","started","EventEmitter","stopped","edge","outOfBounds","top","right","bottom","left","gridSize","inBounds","trackPosition","scale","preventDefaultEvent","position","movingOffset","endOffset","Object","defineProperty","setting","setStyle","nativeElement","undefined","element","handle","addClass","removeClass","ngOnInit","resetPosition","ngOnChanges","changes","isFirstChange","currentValue","transform","moveTo","bounds","emit","boundsCheck","translateX","translateY","Math","round","value","pickUp","style","zIndex","window","getComputedStyle","getPropertyValue","zIndexMoving","boundary","getBoundingClientRect","elem","result","putBack","removeProperty","checkHandleTarget","target","tagName","child","children","hasOwnProperty","onMouseDown","event","button","srcElement","stopPropagation","preventDefault","onMouseLeave","onMouseMove","decorators","type","Directive","args","selector","exportAs","ctorParameters","ElementRef","Renderer2","propDecorators","Output","Input","ngDraggable","HostListener","AngularDraggableModule","NgModule","declarations","exports"],"mappings":"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"}
